# Story 1.5: 搜索列表查询API

## Status
Approved

## Story
**As a** user,
**I want** to be able to view my own and team search history,
**so that** I can quickly browse past research results.

## Acceptance Criteria
1. 个人搜索列表API(/api/search/my)实现
2. 团队搜索列表API(/api/search/team/{teamId})实现
3. 分页和排序功能支持
4. 仅返回标题和创建时间，优化性能
5. 权限验证确保数据访问安全

**Integration Verification:**
- IV1: 查询API响应时间在500ms内，符合现有性能标准
- IV2: 团队权限验证正确，用户只能访问授权团队数据
- IV3: API分页机制与潜在的前端集成兼容

## Tasks / Subtasks

- [ ] Task 1: Personal Search List Service (AC: 1, 4)
  - [ ] Extend src/services/searchService.js with getUserSearchList function
  - [ ] Implement optimized query returning only topic, id, createdAt, status
  - [ ] Add pagination support with limit/offset parameters
  - [ ] Add sorting support (createdAt desc by default)
  - [ ] Optimize database query performance

- [ ] Task 2: Team Search List Service (AC: 2, 4, 5)
  - [ ] Add getTeamSearchList function to searchService.js
  - [ ] Implement team member verification logic
  - [ ] Query searches from all team members
  - [ ] Return optimized search summary data
  - [ ] Add team-specific filtering and sorting

- [ ] Task 3: Search List API Routes (AC: 1, 2, 3)
  - [ ] Add GET /api/search/my to src/routes/search.js
  - [ ] Add GET /api/search/team/:teamId to src/routes/search.js
  - [ ] Implement query parameter handling (page, limit, sort)
  - [ ] Add response pagination metadata
  - [ ] Implement proper error handling

- [ ] Task 4: Pagination and Sorting System (AC: 3, IV: 3)
  - [ ] Create src/utils/pagination.js utility
  - [ ] Implement standardized pagination response format
  - [ ] Add sorting validation and sanitization
  - [ ] Support multiple sort fields and directions
  - [ ] Add pagination metadata (total, page, hasNext, hasPrev)

- [ ] Task 5: Performance Optimization (AC: 4, IV: 1)
  - [ ] Implement database query optimization
  - [ ] Add appropriate database indexes for search list queries
  - [ ] Implement query result caching strategy
  - [ ] Add database query performance monitoring
  - [ ] Optimize JSON response size

- [ ] Task 6: Team Permission Integration (AC: 5, IV: 2)
  - [ ] Integrate with team membership verification from Story 1.3
  - [ ] Implement team access control logic
  - [ ] Add team member role validation
  - [ ] Handle unauthorized team access gracefully
  - [ ] Add audit logging for team search access

- [ ] Task 7: Authentication and Authorization (AC: 5)
  - [ ] Apply JWT auth middleware to all search list routes
  - [ ] Implement user ownership verification for personal searches
  - [ ] Add team membership verification for team searches
  - [ ] Handle authentication failures appropriately

- [ ] Task 8: Response Format Standardization (IV: 3)
  - [ ] Design consistent API response format
  - [ ] Implement search summary data structure
  - [ ] Add response metadata for pagination
  - [ ] Ensure compatibility with frontend expectations
  - [ ] Add API documentation for response formats

- [ ] Task 9: Testing Implementation
  - [ ] Unit tests for search list service functions
  - [ ] Integration tests for API endpoints
  - [ ] Performance tests for query optimization
  - [ ] Team permission and access control tests
  - [ ] Pagination and sorting functionality tests

## Dev Notes

### Previous Stories Insights

**From Story 1.1 (Database Infrastructure):**
- Prisma client available at `src/db/client.js` or `src/database/client.js`
- User model with established relationships
- Database optimization patterns and indexing strategies

**From Story 1.2 (JWT Authentication):**
- JWT authentication middleware at `src/middleware/auth.js`
- User authentication and token validation established
- User ID extraction from JWT tokens for ownership verification

**From Story 1.3 (Team Management):**
- Team and TeamMember models with user relationships
- Team membership verification patterns: Owner/Admin/Member roles
- Team permission validation logic established
- Database transaction patterns for multi-table operations

**From Story 1.4 (Search Data Models):**
- Search model with complete lifecycle (INITIATED → PROCESSING → COMPLETED/FAILED)
- Search model indexed on (userId, createdAt) and status
- SearchResult model with sequence-based ordering
- Established search ownership and access patterns

### Technical Context from Current Project

**Current Tech Stack:**
- Framework: Hono.js v4.9.8 [Source: package.json]
- Database: Prisma + PostgreSQL [Source: Stories 1.1-1.4]
- Authentication: JWT with jsonwebtoken library [Source: Story 1.2]
- Testing: Jest v30.1.3 [Source: package.json]

**Updated Project Structure:**
```
src/
├── middleware/          # proxy.js, errorHandler.js, auth.js
├── routes/             # auth.js, teams.js, search.js
├── services/           # userService.js, teamService.js, searchService.js
├── utils/              # jwt.js, pagination.js (new)
├── db/                 # Prisma client
└── config/             # agents.js, config.js
```

### Search List API Design

**Personal Search List Endpoint:**
```
GET /api/search/my?page=1&limit=20&sort=createdAt:desc
```

**Team Search List Endpoint:**
```
GET /api/search/team/:teamId?page=1&limit=20&sort=createdAt:desc
```

**Query Parameters:**
- `page`: Page number (default: 1)
- `limit`: Items per page (default: 20, max: 100)
- `sort`: Sort field and direction (default: createdAt:desc)
- `status`: Filter by search status (optional)

### Response Format Design

**Search List Response Structure:**
```json
{
  "data": [
    {
      "id": "search_123",
      "topic": "Tesla Q3 2024 Financial Analysis",
      "status": "COMPLETED",
      "createdAt": "2024-09-29T10:00:00Z",
      "userId": "user_456",
      "userName": "John Doe"
    }
  ],
  "pagination": {
    "page": 1,
    "limit": 20,
    "total": 150,
    "totalPages": 8,
    "hasNext": true,
    "hasPrev": false
  },
  "meta": {
    "sortBy": "createdAt",
    "sortOrder": "desc",
    "filters": {
      "status": "COMPLETED"
    }
  }
}
```

**Optimized Data Selection:**
- Only include essential fields: id, topic, status, createdAt, userId
- Include userName for team searches (join with User model)
- Exclude heavy content fields (description, metadata, search results)

### Database Query Optimization

**Personal Search List Query:**
```prisma
// Optimized query using existing index (userId, createdAt)
const searches = await prisma.search.findMany({
  where: { userId },
  select: {
    id: true,
    topic: true,
    status: true,
    createdAt: true,
    userId: true
  },
  orderBy: { createdAt: 'desc' },
  skip: (page - 1) * limit,
  take: limit
});
```

**Team Search List Query:**
```prisma
// Query using team membership from Story 1.3
const searches = await prisma.search.findMany({
  where: {
    user: {
      teamMembers: {
        some: { teamId }
      }
    }
  },
  select: {
    id: true,
    topic: true,
    status: true,
    createdAt: true,
    userId: true,
    user: {
      select: { name: true }
    }
  },
  orderBy: { createdAt: 'desc' },
  skip: (page - 1) * limit,
  take: limit
});
```

### Team Permission Integration

**Team Access Verification:**
1. Verify user is authenticated (JWT middleware)
2. Check user is member of requested team (using TeamMember model from Story 1.3)
3. Apply team member role permissions (all roles can view team searches)
4. Return searches from all team members

**Permission Logic:**
```javascript
// Integrate with team service from Story 1.3
const isTeamMember = await teamMemberService.isUserTeamMember(userId, teamId);
if (!isTeamMember) {
  throw new ForbiddenError('Access denied to team searches');
}
```

### Performance Optimization Strategy

**Database Optimization:**
- Leverage existing indexes: (userId, createdAt), status
- Use selective field queries to minimize data transfer
- Implement cursor-based pagination for large datasets
- Add query result caching for frequently accessed lists

**Response Optimization:**
- Minimal JSON payload with only essential fields
- Efficient pagination metadata calculation
- Response compression for large result sets
- ETags for client-side caching

**Caching Strategy:**
- Cache team membership verification results
- Cache frequently accessed search lists
- Implement cache invalidation on search creation/updates
- Use Redis for distributed caching (future enhancement)

### Pagination Utility Design

**Standardized Pagination Helper:**
```javascript
// src/utils/pagination.js
const createPaginationResponse = (data, page, limit, total) => {
  const totalPages = Math.ceil(total / limit);
  return {
    data,
    pagination: {
      page,
      limit,
      total,
      totalPages,
      hasNext: page < totalPages,
      hasPrev: page > 1
    }
  };
};
```

### Error Handling Strategy

**Authentication Errors:**
- Missing JWT token (401 Unauthorized)
- Invalid JWT token (401 Unauthorized)
- Expired JWT token (401 Unauthorized)

**Authorization Errors:**
- Access to non-existent team (404 Not Found)
- Access to unauthorized team (403 Forbidden)
- Invalid team member permissions (403 Forbidden)

**Validation Errors:**
- Invalid pagination parameters (400 Bad Request)
- Invalid sort parameters (400 Bad Request)
- Invalid filter parameters (400 Bad Request)

**Performance Errors:**
- Query timeout (500 Internal Server Error)
- Database connection failures (503 Service Unavailable)

### Integration with Frontend

**Frontend-Compatible Features:**
- Standardized pagination format for UI components
- Consistent sorting parameter format
- Predictable response structure for data binding
- Error response format compatible with frontend error handling

**Search List UI Considerations:**
- Support for infinite scrolling (cursor-based pagination)
- Real-time search status updates (preparation for Story 1.6 SSE)
- Efficient search result caching and updates
- Responsive design with mobile-optimized pagination

### Future Extension Points

**Enhanced Filtering:**
- Filter by date ranges
- Filter by search status
- Filter by team member
- Full-text search in topics

**Advanced Sorting:**
- Sort by completion time
- Sort by team member name
- Sort by search complexity
- Custom user-defined sorting

**Search Analytics:**
- Track search list access patterns
- Monitor query performance
- User behavior analytics for search discovery

### Testing Strategy

**Test Framework**: Jest [Source: package.json]
**Test Categories:**
- **Unit Tests**: Search list service functions, pagination utility
- **Integration Tests**: API endpoints with authentication and team permissions
- **Performance Tests**: Query efficiency, pagination performance, response time
- **Authorization Tests**: Team access control, permission verification
- **Error Tests**: Invalid parameters, unauthorized access, database failures

**Test File Locations:**
- `tests/services/searchService.test.js` (extend existing)
- `tests/routes/search.test.js` (extend existing)
- `tests/utils/pagination.test.js` (new)
- `tests/integration/searchList.test.js` (new)

### Technical Constraints

**Performance Requirements:**
- Response time under 500ms (IV1)
- Support for large search lists (1000+ searches)
- Efficient pagination for team searches
- Minimal memory usage for query results

**Security Requirements:**
- Strict team access control verification
- Prevent unauthorized data exposure
- Rate limiting for search list requests
- Audit logging for team search access

**Scalability Requirements:**
- Support for teams with many members
- Efficient queries for users with many searches
- Horizontal scaling compatibility
- Database query optimization

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-09-29 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record
*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be filled during implementation*

### Debug Log References
*To be filled during implementation*

### Completion Notes List
*To be filled during implementation*

### File List
*To be filled during implementation*

## QA Results
*Results from QA Agent review will be added here after implementation*